---
title: Charge to Mass Ratio
jupyter: python3
---

```{python}
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
```

Read data

```{python}
data = pd.read_csv("data.csv")
data
```

Calculate Helmholtz Field

```{python}
currents = data.to_numpy()[:, 1:]
mu = 4*np.pi*1E-7
N = 72
R = 0.33
helmholtz_fields = 8*mu*N*currents/(np.sqrt(125)*R)
helmholtz_fields
```

Diameters and voltages 

```{python}
diameters = np.array([0.065,0.078,0.090,0.103,0.115])

voltages = data.to_numpy()[:, 0]
voltages
```

plot values

```{python}
x = helmholtz_fields
y = np.sqrt((2*voltages[:, np.newaxis])/((diameters/2)**2))
slopes = np.zeros((6,2))
intercepts = np.zeros((6,2))

X = np.arange(0,900,100)

cmap = plt.get_cmap("Set1")
plt.figure()

for i in range(len(voltages)):
  plt.scatter(x[i]*1e6, y[i], color=cmap(i), label=f"Voltage: {voltages[i]}V")
  w, c = np.polyfit(x[i], y[i], 1, cov=True)
  e = np.sqrt(np.diag(c)) 
  slopes[i] = (w[0], e[0]) 
  intercepts[i] = (w[1], e[1]) 

plt.title("Radius to Field Given Voltage")
plt.xlabel("Helmholtz Field [$\mu$T]")
plt.ylabel("Square Root of $2V/r^2$ [$\sqrt{V}/m$]")
plt.legend()
plt.show()

for i in range(len(voltages)):
  print(f"{voltages[i]}V:")
  print(f" m = {slopes[i][0]:.3}+-{slopes[i][1]:.3}")
  print(f" b = {intercepts[i][0]:.3}+-{intercepts[i][1]:.3}\n")
```

To get the charge to mass ratio we do the following

$$
m = \sqrt{\frac{e}{m_e}} \implies \frac{e}{m_e} = m^2
$$

and the uncertainty is

$$
\sigma_{e/m_e} = \frac{d \text{ }e/m_e}{d \text{ }m} \sigma_m = 2 m \sigma_ m
$$

Then to calculate $B_e$ we can do 

$$
B_e = \frac{b}{\sqrt{e/m}} = \frac{b}{m}
$$

$$
\sigma_{B_e} = \sqrt{(\frac{\partial B_e}{\partial m} \sigma_m )^2 + (\frac{\partial B_e}{\partial b} \sigma_m ).3} = \sqrt{(\frac{\sigma_m}{m.3})^2 + \sigma_b.3}
$$

and its uncertainty

```{python}
intercepts[:, 0] = intercepts[:, 0]/slopes[:, 0]
intercepts[:, 1] = np.sqrt((slopes[:, 1]/slopes[:, 0]**2)**2 + intercepts[:, 1]**2)

slopes[:, 0] = slopes[:, 0]**2
slopes[:, 1] = slopes[:, 0]*slopes[:, 1]*2

for i in range(len(voltages)):
  print(f"{voltages[i]}V:")
  print(f" e/m = {slopes[i][0]:.3}+-{slopes[i][1]:.3}")
  print(f" B_e = {intercepts[i][0]:.3}+-{intercepts[i][1]:.3}\n")
```

Experimental Earth Field values yield:

```{python}
earth_field = 8*mu*N*0.36/(np.sqrt(125)*R)
earth_field_error = 0.05
print(f"B_e = {earth_field:.3} +- {earth_field_error}T")
```

Both values agree but are not very precise, however the means of the fitted field line up better than the experimental field. The combined mean of a value is defined by

$$
x_\text{combined} = \frac{\Sigma x_i/\sigma_i}{\Sigma 1/\sigma_i},
\sigma_\text{combined} = \frac{1}{\Sigma 1/\sigma_i} 
$$

This means that our combined fit would look like

```{python}
slope, slope_err = (np.sum(slopes[:,0]/slopes[:,1])/np.sum(1/slopes[:,1]),1/np.sum(1/slopes[:,1]))
intercept, intercept_err = (np.sum(intercepts[:,0]/intercepts[:,1])/np.sum(1/intercepts[:,1]),1/np.sum(1/intercepts[:,1]))
print(f" e/m = {slope:.3}+-{slope_err:.3}")
print(f" B_e = {intercept:.3}+-{intercept_err:.3}")
```
