<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lab 5: Faraday</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="faraday_files/libs/clipboard/clipboard.min.js"></script>
<script src="faraday_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="faraday_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="faraday_files/libs/quarto-html/popper.min.js"></script>
<script src="faraday_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="faraday_files/libs/quarto-html/anchor.min.js"></script>
<link href="faraday_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="faraday_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="faraday_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="faraday_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="faraday_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 5: Faraday</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Import libraries</p>
<div id="aac8bcda" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.optimize <span class="im">import</span> curve_fit</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="day-1-direct-current" class="level1">
<h1>Day 1: Direct Current</h1>
<section id="polarization-calibration" class="level2">
<h2 class="anchored" data-anchor-id="polarization-calibration">Polarization Calibration</h2>
<p>Import our data and calculate error</p>
<div id="1e1e414f" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>no_rod <span class="op">=</span> pd.read_csv(<span class="st">"data/day1/no_rod.csv"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>no_rod[<span class="st">"error"</span>] <span class="op">=</span> no_rod[<span class="st">"change"</span>]<span class="op">/</span><span class="dv">2</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>with_rod <span class="op">=</span> pd.read_csv(<span class="st">"data/day1/with_rod.csv"</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>with_rod[<span class="st">"error"</span>] <span class="op">=</span> with_rod[<span class="st">"change"</span>]<span class="op">/</span><span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Plot it around 0 (Wrapping between -180 and 180)</p>
<div id="c45ce7a2" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>angle_no_rod <span class="op">=</span> [x <span class="cf">if</span> x <span class="op">&lt;</span> <span class="dv">180</span> <span class="cf">else</span> x<span class="op">-</span><span class="dv">360</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">list</span>(no_rod[<span class="st">"angle"</span>])]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>voltage_no_rod <span class="op">=</span> <span class="bu">list</span>(no_rod[<span class="st">"voltage"</span>])</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>angle_rod <span class="op">=</span> [x <span class="cf">if</span> x <span class="op">&lt;</span> <span class="dv">180</span> <span class="cf">else</span> x<span class="op">-</span><span class="dv">360</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">list</span>(with_rod[<span class="st">"angle"</span>])]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>voltage_rod <span class="op">=</span> <span class="bu">list</span>(with_rod[<span class="st">"voltage"</span>])</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Polarization Calibration"</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Angle (degrees)"</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Voltage (mV)"</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>plt.errorbar(angle_no_rod, voltage_no_rod, yerr<span class="op">=</span>no_rod[<span class="st">"error"</span>], fmt<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"No Rod"</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>plt.errorbar(angle_rod, voltage_rod, yerr<span class="op">=</span>with_rod[<span class="st">"error"</span>], fmt<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"With Rod"</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>plt.plot()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="faraday_files/figure-html/cell-4-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Note that error is 2 orders of magnitude smaller than the scale of the data, so it is not noticable</p>
</section>
<section id="dc-verlet" class="level2">
<h2 class="anchored" data-anchor-id="dc-verlet">DC Verlet</h2>
<p>Import the data and convert to radians</p>
<div id="718e1751" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>verlet1 <span class="op">=</span> pd.read_csv(<span class="st">"data/day1/dc_verdet_1.csv"</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>verlet2 <span class="op">=</span> pd.read_csv(<span class="st">"data/day1/dc_verdet_2.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Plot the angle change vs intensity (read as current)</p>
<div id="d9490f52" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"DC Verdet Constant Measurement"</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Current (A)"</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Angle Change (degrees)"</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>plt.scatter(verlet1[<span class="st">"current"</span>],verlet1[<span class="st">"angle change"</span>], label<span class="op">=</span><span class="st">"Minimum Intensity"</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>plt.scatter(verlet2[<span class="st">"current"</span>],verlet2[<span class="st">"angle change"</span>], label<span class="op">=</span><span class="st">"Half Intensity"</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="faraday_files/figure-html/cell-6-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Here we are accurate to the about 2 degrees of precision, which is not a whole lot. This will be improved in the AC section.</p>
<p>We can set up some constants to then fit this and find the verlet constant</p>
<div id="3afd8fcf" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="fl">10e-2</span> <span class="co"># length in meters</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="fl">11.1e-3</span> <span class="co"># Calibration constant in T/A</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co"># convert angle to radians</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>verlet1[<span class="st">"angle change"</span>] <span class="op">=</span> np.radians(verlet1[<span class="st">"angle change"</span>])</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>verlet2[<span class="st">"angle change"</span>] <span class="op">=</span> np.radians(verlet2[<span class="st">"angle change"</span>])</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dc_verlet_fit(df):</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    popt, pcov <span class="op">=</span> np.polyfit(df[<span class="st">"current"</span>], df[<span class="st">"angle change"</span>], <span class="dv">1</span>, cov<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    slope, intercept <span class="op">=</span> popt</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    slope_err, intercept_err <span class="op">=</span> np.sqrt(np.diag(pcov))</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    slope_mod <span class="op">=</span> slope <span class="op">/</span> (L <span class="op">*</span> k)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    slope_mod_err <span class="op">=</span> slope_err <span class="op">/</span> (L <span class="op">*</span> k)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (slope_mod, slope_mod_err), (intercept, intercept_err)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>dc_slope1, dc_intercept1 <span class="op">=</span> dc_verlet_fit(verlet1)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>dc_slope2, dc_intercept2 <span class="op">=</span> dc_verlet_fit(verlet2)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Verlet1:"</span>)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Slope/(L*k): </span><span class="sc">{</span>dc_slope1[<span class="dv">0</span>]<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>dc_slope1[<span class="dv">1</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Intercept: </span><span class="sc">{</span>dc_intercept1[<span class="dv">0</span>]<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>dc_intercept1[<span class="dv">1</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Verlet2:"</span>)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Slope/(L*k): </span><span class="sc">{</span>dc_slope2[<span class="dv">0</span>]<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>dc_slope2[<span class="dv">1</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Intercept: </span><span class="sc">{</span>dc_intercept2[<span class="dv">0</span>]<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>dc_intercept2[<span class="dv">1</span>]<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Verlet1:
  Slope/(L*k): 25.7736 ± 9.7505
  Intercept: -0.0378 ± 0.0301
Verlet2:
  Slope/(L*k): 14.6987 ± 2.3216
  Intercept: 0.0103 ± 0.0058</code></pre>
</div>
</div>
<p>Overall not good, but we will improve on that value</p>
</section>
</section>
<section id="day-2-alternating-current" class="level1">
<h1>Day 2: Alternating Current</h1>
<section id="polarization-calibration-1" class="level2">
<h2 class="anchored" data-anchor-id="polarization-calibration-1">Polarization Calibration</h2>
<p>We repeat the polarization calibration on a smaller scale. Given last day’s data, we can safely assume that the rod does not affect polarization just the intensity, so we only inserted the rod and took data once.</p>
<div id="13b54db1" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>polarization <span class="op">=</span> pd.read_csv(<span class="st">"data/day2/polarization.csv"</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>polarization[<span class="st">"error"</span>] <span class="op">=</span> polarization[<span class="st">"change"</span>]<span class="op">/</span><span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Plot it around 0 (Wrapping between -180 and 180)</p>
<div id="c00b4c54" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>angle_day2 <span class="op">=</span> [x <span class="cf">if</span> x <span class="op">&lt;</span> <span class="dv">180</span> <span class="cf">else</span> x<span class="op">-</span><span class="dv">360</span> <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">list</span>(polarization[<span class="st">"angle"</span>])]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>voltage_day2 <span class="op">=</span> <span class="bu">list</span>(polarization[<span class="st">"voltage"</span>])</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Polarization Calibration"</span>)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Angle (degrees)"</span>)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Voltage (mV)"</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>plt.errorbar(angle_no_rod, voltage_no_rod, yerr<span class="op">=</span>no_rod[<span class="st">"error"</span>], fmt<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"No Rod"</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>plt.errorbar(angle_rod, voltage_rod, yerr<span class="op">=</span>with_rod[<span class="st">"error"</span>], fmt<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"With Rod"</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>plt.errorbar(angle_day2, voltage_day2, yerr<span class="op">=</span>polarization[<span class="st">"error"</span>], fmt<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"with Rod Day 2"</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>plt.plot()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="faraday_files/figure-html/cell-9-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Here we see a smaller intensity, but that doesn’t matter as we mainly care about the sinusoidal shape here.</p>
<p>we can linearize the curve as follows, plotting <span class="math inline">\(V\)</span> vs <span class="math inline">\(\cos^2(\theta - \theta_0)\)</span>, as seen from Malus’ Law, just using our empty solonoid</p>
<div id="6aca707d" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>theta_0 <span class="op">=</span> angle_no_rod[np.argmax(voltage_no_rod)]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>V_0 <span class="op">=</span> np.<span class="bu">max</span>(voltage_no_rod)<span class="op">*</span><span class="fl">1e-3</span> <span class="co"># will use this later (converted to volts)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>linearized_angle <span class="op">=</span> [np.cos(np.radians(x <span class="op">-</span> theta_0))<span class="op">**</span><span class="dv">2</span> <span class="cf">for</span> x <span class="kw">in</span> angle_no_rod]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Linearized Polarization"</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Linearized Angle ($</span><span class="ch">\\</span><span class="st">cos^2(</span><span class="ch">\\</span><span class="st">theta - </span><span class="ch">\\</span><span class="st">theta_0)$)"</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Voltage (mV)"</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>plt.errorbar(linearized_angle, voltage_no_rod, yerr<span class="op">=</span>no_rod[<span class="st">"error"</span>], fmt<span class="op">=</span><span class="st">'o'</span>, label<span class="op">=</span><span class="st">"No Rod Linearized"</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>plt.plot()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="faraday_files/figure-html/cell-10-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="ac-verdet" class="level2">
<h2 class="anchored" data-anchor-id="ac-verdet">AC Verdet</h2>
<p>Import the data</p>
<div id="760451e9" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>ac_verdet <span class="op">=</span> pd.read_csv(<span class="st">"data/day2/ac_verdet.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here the experiment is in reverse, we know measure the voltage at a fixed angle, and vary the current. This means we need to find the angle corresponding to the measured voltage. The equation is defined as follows:</p>
<p><span class="math display">\[
\Delta V = \Delta \theta \frac{dV}{d\theta}
\]</span></p>
<p>Where <span class="math inline">\(\frac{dV}{d\theta}\)</span> is the derivative of the voltage found through Malus’ Law. As explained in the lab manual this ends up just being <span class="math inline">\(V_0\)</span>, so we dont need to calculate anything new. This also requires that <span class="math inline">\(\Delta V\)</span> is in RMS instead of peak to peak, so we convert it. Afterwards we average the values and get the standard deviation as the error.</p>
<div id="25dc43a8" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert Delta V to RMS and Volts instead of mV</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> ac_verdet[<span class="st">"Delta V"</span>].mean()<span class="op">*</span><span class="fl">1e-3</span><span class="op">/</span>(np.sqrt(<span class="dv">2</span>))</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>V_std <span class="op">=</span> ac_verdet[<span class="st">"Delta V"</span>].std()<span class="op">*</span><span class="fl">1e-3</span><span class="op">/</span>(np.sqrt(<span class="dv">2</span>))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert Current to Amps</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>I  <span class="op">=</span> ac_verdet[<span class="st">"Current"</span>].mean()<span class="op">*</span><span class="fl">1e-3</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>I_std <span class="op">=</span> ac_verdet[<span class="st">"Current"</span>].std()<span class="op">*</span><span class="fl">1e-3</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"AC Verdet Data:"</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Delta V (Pk-Pk): </span><span class="sc">{</span>ac_verdet[<span class="st">"Delta V"</span>]<span class="sc">.</span>mean()<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>ac_verdet[<span class="st">"Delta V"</span>]<span class="sc">.</span>std()<span class="sc">:.4f}</span><span class="ss"> mV"</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Delta V (RMS): </span><span class="sc">{</span>V<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>V_std<span class="sc">:.4f}</span><span class="ss"> mV"</span>)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"  Current: </span><span class="sc">{</span>I<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>I_std<span class="sc">:.4f}</span><span class="ss"> mA"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>AC Verdet Data:
  Delta V (Pk-Pk): 2.3616 ± 0.1061 mV
  Delta V (RMS): 0.0017 ± 0.0001 mV
  Current: 0.2602 ± 0.0021 mA</code></pre>
</div>
</div>
<p>Note that our voltage here was measured as a Pk-Pk value, however we are treating it as the change in amplitude at peaks, therefore we only need to convert to RMS by dividing by <span class="math inline">\(\sqrt{2}\)</span>.</p>
<p>We did not have time to get data for every test, so we took our initial 25 points of noisy data, and quantitatively looked at the other methods to see where improvements could be made in the future.</p>
<p>Now we can go and calculate the Verdet constant from this data point, recalling that <span class="math inline">\(\Delta \theta\)</span> is the same as the DC case. solving for <span class="math inline">\(\Delta \theta\)</span> and dividing by <span class="math inline">\(Lk\)</span> gives us the Verdet constant.</p>
<div id="13ea8e2f" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>dTheta <span class="op">=</span> V <span class="op">/</span> V_0</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Delta Theta: </span><span class="sc">{</span>dTheta<span class="sc">:.4f}</span><span class="ss"> radians"</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> dTheta<span class="op">/</span>(k<span class="op">*</span>I<span class="op">*</span>L)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>C_err <span class="op">=</span> C <span class="op">*</span> np.sqrt( (V_std<span class="op">/</span>V)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (I_std<span class="op">/</span>I)<span class="op">**</span><span class="dv">2</span> )</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"AC Verdet Constant: </span><span class="sc">{</span>C<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>C_err<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Delta Theta: 0.0054 radians
AC Verdet Constant: 18.8349 ± 0.8595</code></pre>
</div>
</div>
<p>We can compare our uncertainty to the noise in our original data as</p>
<div id="52cb8b63" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>original_noise <span class="op">=</span> (ac_verdet[<span class="st">"Noise Top"</span>]<span class="op">/</span><span class="dv">2</span><span class="op">+</span>ac_verdet[<span class="st">"Noise Bottom"</span>]<span class="op">/</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">2</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co"># This time it is actually pk-pk noise, so divide by 2 to get amplitude</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>noise_mean <span class="op">=</span> original_noise.mean()<span class="op">*</span><span class="fl">1e-3</span><span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>np.sqrt(<span class="dv">2</span>)) </span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>noise_std <span class="op">=</span> original_noise.std()<span class="op">*</span><span class="fl">1e-3</span><span class="op">/</span>(<span class="dv">2</span><span class="op">*</span>np.sqrt(<span class="dv">2</span>))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Original Noise (RMS): </span><span class="sc">{</span>noise_mean<span class="sc">:.4f}</span><span class="ss"> ± </span><span class="sc">{</span>noise_std<span class="sc">:.4f}</span><span class="ss"> mV"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Original Noise (RMS): 0.0002 ± 0.0000 mV</code></pre>
</div>
</div>
<p>Sadly we did not have enough measurements to beat out noise</p>
</section>
<section id="gain" class="level2">
<h2 class="anchored" data-anchor-id="gain">Gain</h2>
<p>For this section we only have one data point, so we cannot calculate an error, but we can still calculate a value for the Verdet constant, to compare to our other methods.</p>
<div id="f3cf0259" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>V_raw <span class="op">=</span> <span class="fl">23.6</span><span class="op">*</span><span class="fl">1e-3</span><span class="op">/</span>(np.sqrt(<span class="dv">2</span>)) </span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> V_raw<span class="op">/</span><span class="dv">10</span> <span class="co"># divide by gain of 10</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> <span class="fl">258.3</span><span class="op">*</span><span class="fl">1e-3</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>gain_verdet <span class="op">=</span> (V <span class="op">/</span> V_0)<span class="op">/</span>(k<span class="op">*</span>I<span class="op">*</span>L)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Gain Verdet Constant: </span><span class="sc">{</span>gain_verdet<span class="sc">:.4f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Gain Verdet Constant: 18.9588</code></pre>
</div>
</div>
<p>We get a fairly similar value here, showing that the gain does not affect the measurement, just the signal to noise ratio, our measurements for the noise tended to be fairly similar to the non gained measurements.</p>
</section>
<section id="filter" class="level2">
<h2 class="anchored" data-anchor-id="filter">Filter</h2>
<p>Now we use a filter to improve our signal to noise ratio. With one measurement at each Q factor, we cannot calculate a standard deviation, so we cannot calculate an error, however it allows us to get a rough idea of how well this method works.</p>
<div id="c1fb79fa" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>filtered <span class="op">=</span> pd.read_csv(<span class="st">"data/day2/filter.csv"</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> filtered[<span class="st">"Delta V"</span>]<span class="op">*</span><span class="fl">1e-3</span><span class="op">/</span>(np.sqrt(<span class="dv">2</span>))</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> filtered[<span class="st">"Current"</span>]<span class="op">*</span><span class="fl">1e-3</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>filter_verdet <span class="op">=</span> (V <span class="op">/</span> V_0)<span class="op">/</span>(k<span class="op">*</span>I<span class="op">*</span>L) <span class="op">/</span> (<span class="dv">10</span>) <span class="co"># divide by Q factor and gain</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can display the results as a bar chart</p>
<div id="d95e94ff" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>plt.figure()</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Filtered Verdet Constant Measurements"</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"Q Factor"</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"Verdet Constant (rad/T·m)"</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>plt.bar(<span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">str</span>,filtered[<span class="st">"Q"</span>])), filter_verdet)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="faraday_files/figure-html/cell-17-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>There is a chance that there was some parasitic coupling in the filter that caused some issues, as the values do not seem to improve with higher Q factor as expected. Further testing would be required to confirm this. My assumption was the Q factor also amplified the signal, however it seems that it only improves the signal to noise ratio, which means there is a lot of systematic error here that we are not accounting for.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>